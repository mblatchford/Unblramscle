{"version":3,"sources":["Square.js","InitGame.js","Picture.js","Winner.js","GameBoard.js","App.js","serviceWorker.js","index.js"],"names":["Square","props","tileClass","gridSize","react_default","a","createElement","className","squares","map","tile","checkBackPosX","backgroundPos","xPos","checkBackPosY","yPos","isClicked","clicked","id","key","uuid","concat","value","style","backgroundPositionX","backgroundPositionY","outline","onClick","handleClick","InitGame","grid","startButton","reset","buttonReturn","newImage","size","startBool","Picture","Winner","displayWinner","hidden","ifWinner","GameBoard","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","_handleTileClicks","tileID","setState","toConsumableArray","state","length","_swapTiles","clickedID1","clickedID2","mapIndex","shuffled","index","tileIndex1","indexOf","tileIndex2","newArray","temp","_ifHasWon","masterIndex","ordered","object","comparison","JSON","stringify","console","log","winner","setTimeout","window","location","reload","_randomizeTiles","shuffledTiles","i","j","Math","floor","random","_ref","_gridSize","gridDirection","curGridSize","_howManytoRender","arrayPos","_backgroundPos","push","xLength","yLength","x","y","backgroundPosArray","table","_gameStart","start","_resetGame","_newImageHandler","src_InitGame","src_Picture","src_Winner","src_Square","Component","App","src_GameBoard","Boolean","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.dce96c0f.chunk.js","sourcesContent":["import React from 'react';\nimport uuid from 'uuid';\n\nconst Square = (props) => {\n  // Dynamically adding the appropriate CSS class per grid size chosen\n  let tileClass = '2x tile_container_x2';\n  switch(props.gridSize){\n    case 3:\n      tileClass = 'x3 tile_container_x3'\n      break;\n    case 4:\n      tileClass = 'x4 tile_container_x4'\n      break;\n    case 5:\n      tileClass = 'x5 tile_container_x5'\n      break;\n    case 6:\n      tileClass = 'x6 tile_container_x6';\n      break;\n    default:\n      tileClass = 'x2 tile_container_x2'\n      break;\n  }\n\n  // Map through array of tiles making sure it pulls only data actually in a finished setState\n  // Injects tile specific background image position data into CSS\n  // Adds click handler to each tile\n  // Highlights the first clicked tile in a swap\n\n  return (\n    <div className={tileClass}>\n\n        {props.squares.map((tile) => {\n          const checkBackPosX = tile.backgroundPos && tile.backgroundPos.xPos ? tile.backgroundPos.xPos : 0;\n          const checkBackPosY = tile.backgroundPos && tile.backgroundPos.yPos ? tile.backgroundPos.yPos : 0;\n          const clicked = props.clicked[0];\n          const isClicked = clicked === tile.id ? `6px solid red` : 'none'\n          return <div \n            key = {uuid()}\n            id = {`tilePos${tile.value-1}`}\n            style = {{\n              backgroundPositionX: checkBackPosX + `px`,\n              backgroundPositionY: checkBackPosY + `px`,\n              outline: isClicked,\n            }}  \n            className={`tile ${tileClass} `}\n            onClick={() => props.handleClick(tile.id)}\n          > \n          </div>\n         })\n        }\n    </div>\n  );\n};\n\nexport default Square;","import React from 'react';\n\n\nconst InitGame = (props) => {\n  const grid = props.grid;  \n  \n  // Main logic gatekeeper:\n  // If you pressed the start button it replaces all current buttons with a reset and has your image shuffled\n  // Otherwise it defaults to NewImage/Tile++/Tile--/Start\n  const initReturn = () => {\n    return props.startBool ? startButton() : buttonReturn() \n  }\n\n  const startButton = () => {\n    return (\n      <div>\n        <button className=\"reset\" onClick={() => props.reset()}>Reset</button>\n      </div>\n    )\n  }\n\n  // Button logic is it's own gatekeeper adding/removing inc and dec buttons as necessary\n  const buttonReturn = () => { \n    if(grid === 2 ){\n      return(\n        <div>\n          <button className=\"newImg\" onClick={() => props.newImage()}>New Image</button>\n          <button className=\"gridInc\" onClick={() => props.size(\"inc\")}>Tiles++</button>\n          <button className=\"start\" onClick={() => props.startButton()}>Start</button>\n        </div>\n      )\n    }else if(grid >= 3 && grid <= 5){\n      return(\n        <div>\n          <button className=\"newImg\" onClick={() => props.newImage()}>New Image</button>\n          <button className=\"gridInc\" onClick={() => props.size(\"inc\")}>Tiles++</button>\n          <button className=\"gridDec\" onClick={() => props.size(\"dec\")}>Tiles--</button>\n          <button className=\"start\" onClick={() => props.startButton()}>Start</button>\n        </div>\n      )\n    }else if(grid === 6){\n      return(\n        <div>\n          <button className=\"newImg\" onClick={() => props.newImage()}>New Image</button>\n          <button className=\"gridDec\" onClick={() => props.size(\"dec\")}>Tiles--</button>\n          <button className=\"start\" onClick={() => props.startButton()}>Start</button>\n        </div>\n      )\n    }\n  }\n  \n  return (\n    <div>\n      {initReturn()}\n     </div>\n  );\n};\n\nexport default InitGame;","import React from 'react';\n\n// Picture is always rendered as a placeholder div w/CSS background image applied\nconst Picture = () => {\n  return (\n    <div className='answerKeyImg'>\n   \n    </div>\n  );\n};\n\nexport default Picture;","import React from 'react';\n\n// Winner text is set to a const that only is sent to JSX if the winner state is true\nconst Winner = (props) => {\n    const displayWinner = \n    <div>\n        <div className=\"winner\">y<div className=\"juxtapose\">o</div>u</div>\n        <div className=\"winner\"><div className=\"juxtapose\">w</div>i<div className=\"juxtapose\">n</div>!</div> \n    </div>;\n   \n    const hidden =\n        props.ifWinner ? displayWinner : null;\n    \n    return (\n        <div>\n            {hidden}\n        </div>\n    );\n};\n\nexport default Winner;","import React, { Component } from 'react';\nimport uuid from 'uuid';\n\nimport Square from  './Square';\nimport InitGame from './InitGame';\nimport Picture from './Picture';\nimport Winner from './Winner';\n\nclass GameBoard extends Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.state={\n\t\t\tshuffled: [], //Main array of tiles that get shuffled\n\t\t\tordered: [],  //Secondary array holds the inital position of tiles before any shuffling         \n\t\t\tclicked: [],\t//Array keeps record of what tiles were clicked in order to swap when necessary\n\t\t\tgrid: 2, \t\t\t//Default grid length is 2x2\n\t\t\tstart: false,\t//Start button pressed logic\n\t\t\twinner: false,//Game was won\n\t\t} \n\t}\n\n\t// makes copy of array before any shuffling one time after initial render\n\tcomponentDidMount(){\n\t\tthis._howManytoRender()\n\t}\n\n\t\t\t\t\t \n\t_handleTileClicks = (tileID) => {\n\t\tthis.setState({\n\t\t\t clicked: [...this.state.clicked, tileID]\n\t\t}, () => {\n\t\t\tconst isPairClicked = this.state.clicked.length === 2;\n\t\t\tif(isPairClicked){\n\t\t\t\tthis._swapTiles();\n\t\t\t}\n\t\t})\n\t}\n\n\n\t _swapTiles = () => {\n\t\t//  second click occured reset clicked array\n\t\tthis.setState({ \n\t\t\tclicked: []\n\t\t}) \n\t\t\tif(this.state.clicked[0] !== this.state.clicked[1]){\n\t\t\t\t// ID values of each clicked tile\n\t\t\t\tconst clickedID1 =  this.state.clicked[0];\n\t\t\t\tconst clickedID2 =  this.state.clicked[1];\n\t\t\t\t// array of tiles by id\n\t\t\t\tconst mapIndex = this.state.shuffled.map(index => {\n\t\t\t\t\treturn index.id \n\t\t\t\t});\n\t\t\t\t// indicies in tiles[] of the clicked tile uuid\n\t\t\t\tconst tileIndex1 = mapIndex.indexOf(clickedID1);\n\t\t\t\tconst tileIndex2 = mapIndex.indexOf(clickedID2);\n\n\t\t\t\t// perform swap\n\t\t\t\t// copy array\n\t\t\t\tconst newArray = [...this.state.shuffled];\n\t\t\t\t// copy value to be overwritten\n\t\t\t\tconst temp = newArray[tileIndex1];\n\t\t\t\t// reassign values\n\t\t\t\tnewArray[tileIndex1] = newArray[tileIndex2];\n\t\t\t\tnewArray[tileIndex2] = temp;\n\n\t\t\t\tthis.setState({\n\t\t\t\t\tshuffled: newArray\n\t\t\t\t}, () =>  this._ifHasWon() )\n\n\t\t \n\t\t\t\t\n\t\t\t} //else do nothing if same button is clicked (effective reset)\n\t}\n\n\n\t_ifHasWon = () => {\n\t\t// map each to compare arrays of id's\n\t\tconst masterIndex = this.state.ordered.map(object => {\n\t\t\treturn object.id; \n\t\t});\n\t\tconst comparison = this.state.shuffled.map(object => {\n\t\t\treturn object.id; \n\t\t});\n\n\t\tif (JSON.stringify(comparison) === JSON.stringify(masterIndex)) {\n\t\t\tconsole.log('Winner');\n\t\t\tthis.setState({\n\t\t\t\twinner: true\n\t\t\t})\n\t\t\t// hacky reset button\n\t\t\tsetTimeout(function(){ \twindow.location.reload(); }, 3000);\n\t\t \n\t\t}\n\t \n\t}\n\n\n\n\t_randomizeTiles = () => {\n\t\tconst shuffledTiles = [...this.state.shuffled];\n\n\t\tfor (let i = shuffledTiles.length - 1; i > 0; i--) {\n\t\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t\t[shuffledTiles[i], shuffledTiles[j]] = [shuffledTiles[j], shuffledTiles[i]];\n\t\t}\n\t\tthis.setState({\n\t\t\tshuffled: shuffledTiles \n\t\t})\n\n\t}\n\t// Method handles passing off the addition and subtraction of tiles\n\t_gridSize = (gridDirection) => {\n\t\tconst curGridSize= this.state.grid;\n\t\tif(gridDirection === 'inc'){\n\t\t\tthis.setState({\n\t\t\t\tgrid: curGridSize + 1 \n\t\t\t}, () => {\n\t\t\t\tthis._howManytoRender()\n\t\t\t})\n\n\t\t}else if(gridDirection === 'dec'){\n\t\t\tthis.setState({\n\t\t\t\tgrid: curGridSize - 1 \n\t\t\t}, () => \n\t\t\t\t{\n\t\t\t\tthis._howManytoRender()\n\t\t\t})\n\t\t}\n\n\t}\n\t\n\t\t// Method takes the grid value, calculates total tiles required, \n\t\t// gives each one a hidden value, a unique id and \n\t\t//an object that stores background image position data\n\t_howManytoRender = () => {\n\t\tconst grid = this.state.grid;\n\t\tconst gridSize = grid * grid;\n\t\tconst newArray = [];\n\t\tconst arrayPos = this._backgroundPos();\n\t\tfor(let i = 0; i < gridSize; i++){\n\t\t\tnewArray.push({'value':i+1, 'id': uuid(), 'backgroundPos': arrayPos[i]\n\t\t\t});\n\t\t}\n\t\tthis.setState({ \n\t\t\tshuffled: newArray  \n\t\t})\n\t}\n\t\n\t// Method calculates each \"window\" of the background image to show on a given tile\n\t_backgroundPos = () => {\n\t\t// grid tells me how many tiles in a given col||row\n\t\tconst grid = this.state.grid;\n\t\t// actual upperleft img position starting coordinates\n\t\t// all images hardcoded to 800x600 resolution\n\t\tconst xLength = 800/grid;\n\t\tconst yLength = 600/grid;\n\t\tlet x = 800;\n\t\tlet y = 600;\n\t\tconst backgroundPosArray = [];\n\t\t// x & y reversed in nested loops to allow for row precedence instead of filling by column first\n\t\t// this because using css grid to display tiles restricts to placement in this order\n\t\t\tfor(let i = 0; i >= -(yLength*(grid-1)); i= i-yLength){\n\t\t\t\t\ty = i\n\t\t\t\tfor(let j = 0; j >= -(xLength*(grid-1));  j= j-xLength){\n\t\t\t\t x = j\n\t\t\t\t\tbackgroundPosArray.push({xPos: x, yPos: y})   \n\t\t\t\t}\n\t\t\t}\n\t\t\tconsole.log(\"ImagePositions\")\n\t\t\tconsole.table(backgroundPosArray);\n\t\t\treturn backgroundPosArray;\n\t}\n\n\t// Helper to toggle start button state and call the tile shuffle method\n\t// Also where once user has selected the image to play \n\t//a copy of the array is made as a comparison key\n\t_gameStart = () => {\n\t\tthis.setState({\n\t\t\tstart: true, \n\t\t\tordered: this.state.shuffled, \n\t\t}, () => this._randomizeTiles())\n\t}\n\n\t//Reset button allows for reselecting number of tile divisions on given image\n\t// It sets all calculations back to defaults but doesn't refresh image selection\n\t_resetGame = () => {\n\t\tthis.setState({\n\t\t\tshuffled: [], \n\t\t\tordered: [],           \n\t\t\tclicked: [],\n\t\t\tgrid: 2,\n\t\t\tstart: false,\n\t\t\twinner: false,\n\t\t}, () => this._howManytoRender())\n\t}\n\n\t// hacky fix just reloads the page to refresh image\n\t_newImageHandler = () => {\n\t\twindow.location.reload(); \n\t}\n\n\trender() { \n\n\t\treturn (\n\t\t\t<div className=\"wrapper\">\n\t\t\t\t<h1>\n\t\t\t\t\tscramble<div className=\"juxtapose\">un</div>\n\t\t\t\t\t{/* scramble<div className=\"juxtapose\">Un</div>ram<div className=\"juxtapose\">sc</div>e */}\n\t\t\t\t</h1>\n\t\t\t\t<div className=\"interface\">\n\t\t\t\t\t<InitGame \n\t\t\t\t\t\t// passing method, chain will render num tiles required\n\t\t\t\t\t\tsize = {this._gridSize} \n\t\t\t\t\t\t// passing current grid: value\n\t\t\t\t\t\tgrid = {this.state.grid}\n\t\t\t\t\t\t// button handler funtions\n\t\t\t\t\t\tstartButton = {this._gameStart}\n\t\t\t\t\t\tstartBool = {this.state.start}\n\t\t\t\t\t\treset = {this._resetGame}\n\t\t\t\t\t\tnewImage = {this._newImageHandler}\n\t\t\t\t\t/>\n\t\t\t\t\t{/* Picture component is a smaller unshuffled version of the shuffled image as reference */}\n\t\t\t\t\t{/* Winner component only visible on a win */}\n\t\t\t\t\t<div className=\"picture\">\n          \t<Picture />\n\t\t\t\t\t\t<Winner ifWinner = {this.state.winner} />\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t\t{/* Tiles are rendered here from the Square component */}\n\t\t\t\t\t<div className=\"board_container\"> \n\t\t\t\t\t<Square  \n\t\t\t\t\t\tgridSize = {this.state.grid}\n\t\t\t\t\t\thandleClick = {this._handleTileClicks}\n\t\t\t\t\t\tsquares={this.state.shuffled}\n\t\t\t\t\t\tclicked={this.state.clicked}\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\t\t\t\t\n\t\t</div>\n\n\t\t);\n\t}\n}\n\nexport default GameBoard;","import React, { Component } from 'react';\nimport './App.css';\nimport GameBoard from './GameBoard';\n\nclass App extends Component {\n  render() {\n    return (\n     <div>\n       <GameBoard />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}